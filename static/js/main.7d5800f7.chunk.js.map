{"version":3,"sources":["components/Header.js","components/IconCard.js","components/Score.js","App.js","serviceWorker.js","index.js"],"names":["style","title","textAlign","color","Header","props","react_default","a","createElement","className","iconImage","width","height","IconCard","id","value","onClick","clickedIcon","src","image","alt","scoreDiv","scores","padding","Score","currentScore","highScore","status","shuffleIcons","array","iconCount","length","index","Math","floor","random","newArray","App","state","result","clicked","Icons","gameOver","console","log","concat","_this","includes","resetGame","pointIncrease","push","setState","score","resetIconArray","points","newOrder","this","_this2","components_Header","components_Score","map","icon","components_IconCard","key","Component","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.7d5800f7.chunk.js","sourcesContent":["import React from \"react\";\n\nconst style = {\n    title: {\n        textAlign: \"center\",\n        color: \"white\"\n    }\n};\n\nconst Header = props => (\n    <div style={style.title} className=\"container\">\n        <h1>Mountain Memory Match</h1>\n        <p>Collect all your supplies one at a time, but don't overpack!</p>\n        <p>If you pick an item twice, your pack will be too heavy and you lose.</p>\n        <h3>Let's Camp!</h3>\n    </div>\n);\n\nexport default Header;","import React from \"react\";\n\nconst style={\n    iconImage: {\n        width: 150,\n        height: 150\n    }\n}\n\nconst IconCard = props => (\n    <div id={props.id} style={style.iconImage} value={props.id} onClick={() => props.clickedIcon(props.id)\n    }>\n        <img src={props.image} alt=\"camping-icon\" />\n    </div>\n);\n\nexport default IconCard;\n","import React from \"react\";\n\nconst style = {\n    scoreDiv: {\n        textAlign: \"center\"\n    },\n    scores: {\n        color: \"white\",\n        padding: 10\n    }\n};\n\nconst Score = props => (\n    <div style={style.scoreDiv} className=\"container\">\n        <p style={style.scores}>Current Score: {props.currentScore}</p>\n        <p style={style.scores}>High Score: {props.highScore}</p>\n        <p style={style.scores}>{props.status}</p>\n    </div>\n);\n\nexport default Score;","import React, { Component } from 'react';\nimport './App.css';\nimport Header from \"./components/Header\";\nimport IconCard from \"./components/IconCard\";\nimport Score from \"./components/Score\";\nimport Icons from \"./icons.json\"\nimport \"./components/IconCard.css\";\n\nconst shuffleIcons = array => {\n    let iconCount = array.length;\n    while (iconCount > 0) {\n        let index = Math.floor(Math.random()*iconCount);\n        iconCount--;\n        let newArray = array[iconCount];\n        array[iconCount] = array[index];\n        array[index] = newArray;\n    }\n    return array;\n};\n\nclass App extends Component {\n\n    state = {\n        currentScore: 0,\n        highScore: 0,\n        result: \"\",\n        clicked: [],\n        Icons, \n        gameOver: false\n    };\n\n    componentDidMount(){\n        this.setState({result: \"Pick an item to start packing!\"})\n    };\n\n    clickedIcon = (id) => {\n        console.log(`Item id: ${id}`);\n        if(!this.state.clicked.includes(id)){\n            this.pointIncrease();\n            this.state.clicked.push(id);\n            this.setState({\n                gameOver: false\n            });\n        } else {\n            this.resetGame();\n        };\n    };\n\n    pointIncrease = () => {\n        let score = this.state.currentScore + 1;\n        if (score === this.state.Icons.length) {\n            this.setState({\n                result: \"You're finished packing! Time to get outside. Or click an icon to play again.\",\n                highScore: score,\n                currentScore: 0,\n                clicked: [],\n                Icons,\n                gameOver: false\n            });\n        } else if (score>this.state.highScore){\n            this.setState({\n                highScore: score,\n                currentScore: score,\n                result: \"Awesome! You've got the new high score!\"\n            });\n        } else {\n            this.setState({\n                currentScore: score,\n                result: \"Good thinking. Item packed.\"\n            });\n        }\n        this.resetIconArray();\n    };\n\n    resetGame = () => {\n        this.setState({\n            points: 0, \n            currentScore: 0,\n            highScore: this.state.highScore,\n            result: \"Your pack is too heavy! No way you'll make it in the wild.\",\n            clicked: [],\n            Icons,\n            gameOver: true\n        });\n        this.resetIconArray();\n    };\n\n    resetIconArray = () => {\n        let newOrder = shuffleIcons(Icons);\n        this.setState({Icons: newOrder});\n    };\n\n    render(){\n        return (\n            <div className=\"container\">\n                <Header />\n                <Score highScore={this.state.highScore} currentScore={this.state.currentScore} status={this.state.result}/>\n                <div className=\"iconCardStyle\">\n                {this.state.Icons.map(icon => (\n                    <IconCard\n                    id={icon.id}\n                    image={icon.image}\n                    clickedIcon={this.clickedIcon}\n                    key={icon.id}\n                    />\n                    ))}\n                </div>\n            </div>\n        )\n    }\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}